"""
SessionPsychologyEngine v3.0 - Fundamentalna Refaktoryzacja
M√ìZG systemu psychometrycznego na poziomie sesji

Filozofia: Jeden, ewoluujƒÖcy profil psychologiczny per sesja
"""

import json
import asyncio
import logging
from typing import Dict, List, Any, Optional
from datetime import datetime
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update
from sqlalchemy.orm import selectinload
from app.core.database import engine  # KRYTYCZNA NAPRAWA: Fresh session dla background task

from app.models.domain import Session, Interaction, Client
from app.services.ai_service import ai_service

logger = logging.getLogger(__name__)

class SessionPsychologyEngine:
    """
    CORE ENGINE: Silnik Psychologiczny na Poziomie Sesji
    
    Odpowiada za:
    1. CiƒÖg≈Çe budowanie profilu psychologicznego przez ca≈ÇƒÖ sesjƒô
    2. Konwersjƒô suggested_questions na interaktywne pytania
    3. Syntezƒô profilu w Customer Archetype
    4. ZarzƒÖdzanie confidence levels
    """
    
    # ETAP 5: Predefiniowane Archetypy Klient√≥w
    CUSTOMER_ARCHETYPES = {
        "analityk": {
            "name": "üî¨ Analityk",
            "description": "Wysoka Sumienno≈õƒá, Compliance (DISC), Warto≈õƒá: Bezpiecze≈Ñstwo",
            "psychological_profile": {
                "big_five": {"conscientiousness": "high", "openness": "medium"},
                "disc": {"compliance": "high", "steadiness": "medium"}, 
                "schwartz": ["security", "conformity"]
            },
            "sales_strategy": {
                "do": ["Dostarczaj twarde dane i statystyki", "Prezentuj TCO i ROI", "Dawaj czas na przemy≈õlenie"],
                "dont": ["Nie naciskaj na szybkƒÖ decyzjƒô", "Nie pomijaj szczeg√≥≈Ç√≥w technicznych", "Nie u≈ºywaj emocjonalnych argument√≥w"]
            }
        },
        "wizjoner": {
            "name": "üöÄ Wizjoner", 
            "description": "Wysoka Otwarto≈õƒá, Dominance + Influence (DISC), Warto≈õƒá: OsiƒÖgniƒôcia",
            "psychological_profile": {
                "big_five": {"openness": "high", "extraversion": "high"},
                "disc": {"dominance": "high", "influence": "high"},
                "schwartz": ["achievement", "self_direction"]
            },
            "sales_strategy": {
                "do": ["Podkre≈õlaj innowacyjno≈õƒá i przysz≈Ço≈õƒá", "M√≥w o statusie i presti≈ºu", "Prezentuj wizjƒô d≈ÇugoterminowƒÖ"],
                "dont": ["Nie skupiaj siƒô tylko na kosztach", "Nie wdawaj w nadmierne szczeg√≥≈Çy", "Nie ograniczaj do obecnych potrzeb"]
            }
        },
        "relacyjny_budowniczy": {
            "name": "ü§ù Relacyjny Budowniczy",
            "description": "Wysoka Ugodowo≈õƒá, Steadiness (DISC), Warto≈õƒá: ≈ªyczliwo≈õƒá", 
            "psychological_profile": {
                "big_five": {"agreeableness": "high", "conscientiousness": "medium"},
                "disc": {"steadiness": "high", "influence": "medium"},
                "schwartz": ["benevolence", "tradition"]
            },
            "sales_strategy": {
                "do": ["Buduj osobistƒÖ relacjƒô", "Podkre≈õlaj korzy≈õci dla zespo≈Çu/rodziny", "U≈ºywaj referencji i opinii"],
                "dont": ["Nie bƒÖd≈∫ zbyt agresywny", "Nie ignoruj emocji i relacji", "Nie podejmuj za niego decyzji"]
            }
        },
        "szybki_decydent": {
            "name": "‚ö° Szybki Decydent",
            "description": "Wysoka Ekstrawersja, Dominance (DISC), Warto≈õƒá: W≈Çadza",
            "psychological_profile": {
                "big_five": {"extraversion": "high", "conscientiousness": "low"},
                "disc": {"dominance": "high", "compliance": "low"},
                "schwartz": ["power", "achievement"]
            },
            "sales_strategy": {
                "do": ["Prezentuj kluczowe korzy≈õci szybko", "Podkre≈õlaj przewagƒô konkurencyjnƒÖ", "Oferuj natychmiastowe dzia≈Çanie"],
                "dont": ["Nie przeciƒÖgaj prezentacji", "Nie wdawaj siƒô w szczeg√≥≈Çy techniczne", "Nie zwlekaj z ofertƒÖ"]
            }
        }
    }

    async def update_cumulative_profile(self, session_id: int, old_db: Optional[AsyncSession] = None) -> Dict[str, Any]:
        """
        G≈Å√ìWNA FUNKCJA LOGIKI - Uruchamiana po ka≈ºdej nowej interakcji
        
        KRYTYCZNA NAPRAWA v3.0: Tworzy ≈õwie≈ºƒÖ sesjƒô DB dla background task
        
        1. Pobiera sesjƒô i CA≈ÅƒÑ historiƒô interakcji
        2. Pobiera obecny cumulative_psychology 
        3. Tworzy potƒô≈ºny prompt dla AI z ca≈ÇƒÖ historiƒÖ + obecnym profilem
        4. AI zwraca: zaktualizowany profil + confidence + suggested_questions + archetyp
        5. Zapisuje wyniki w session
        """
        # KRYTYCZNA NAPRAWA: Stw√≥rz ≈õwie≈ºƒÖ, dedykowanƒÖ sesjƒô dla background task
        async with AsyncSession(engine) as fresh_db:
            try:
                logger.info(f"üß† [SESSION ENGINE FRESH] Rozpoczynam update cumulative profile dla sesji {session_id}")
                
                # 1. Pobierz sesjƒô z ca≈ÇƒÖ historiƒÖ interakcji
                query = (
                    select(Session)
                    .options(selectinload(Session.interactions))
                    .where(Session.id == session_id)
                )
                result = await fresh_db.execute(query)
                session = result.scalar_one_or_none()
                
                if not session:
                    raise ValueError(f"Sesja {session_id} nie zosta≈Ça znaleziona")
                
                # 2. Zbuduj pe≈ÇnƒÖ historiƒô rozmowy
                conversation_history = self._build_session_conversation_history(session.interactions)
                current_profile = session.cumulative_psychology if session.cumulative_psychology else {}
                current_confidence = int(session.psychology_confidence) if session.psychology_confidence else 0
                
                logger.info(f"üß† [SESSION ENGINE] Historia: {len(session.interactions)} interakcji, obecny confidence: {current_confidence}%")
                
                # 3. Stw√≥rz enhanced prompt dla AI z ca≈Çym kontekstem
                psychology_prompt = self._build_cumulative_psychology_prompt(
                    conversation_history, 
                    current_profile, 
                    current_confidence
                )
                
                # 4. Wywo≈Çaj AI service
                ai_response = await asyncio.to_thread(
                    ai_service._sync_ollama_call,
                    psychology_prompt,
                    "Wykonaj analizƒô psychometrycznƒÖ zgodnie z instrukcjami w system prompt."
                )
                
                # 5. Parsuj odpowied≈∫ AI
                parsed_result = self._parse_psychology_ai_response(ai_response)
                
                if parsed_result:
                    # 6. Konwertuj suggested_questions na interactive format
                    interactive_questions = self._convert_to_interactive_questions(
                        parsed_result.get('suggested_questions', [])
                    )
                    
                    # 7. Zaktualizuj sesjƒô
                    await self._update_session_psychology(
                        fresh_db, session_id, parsed_result, interactive_questions
                    )
                    
                    logger.info(f"‚úÖ [SESSION ENGINE] Profile updated: confidence={parsed_result.get('psychology_confidence', 0)}%")
                    return parsed_result
                else:
                    logger.warning(f"‚ö†Ô∏è [SESSION ENGINE] Brak parsowanych wynik√≥w dla sesji {session_id}")
                    return {}
                
            except Exception as e:
                logger.error(f"‚ùå [SESSION ENGINE FRESH] B≈ÇƒÖd podczas update profile sesji {session_id}: {e}")
                await fresh_db.rollback()
                return {}

    async def answer_clarifying_question(self, session_id: int, question_id: str, answer: str, db: AsyncSession):
        """
        Uruchamiana gdy sprzedawca kliknie odpowied≈∫ na pytanie pomocnicze
        
        1. Tworzy "sztucznƒÖ" interakcjƒô z odpowiedziƒÖ sprzedawcy
        2. Usuwa odpowiedziane pytanie z active_clarifying_questions  
        3. Ponownie uruchamia full cycle update_cumulative_profile
        """
        try:
            logger.info(f"üéØ [CLARIFYING] Przetwarzam odpowied≈∫ na pytanie {question_id}: {answer}")
            
            # 1. Pobierz sesjƒô
            query = select(Session).where(Session.id == session_id)
            result = await db.execute(query)
            session = result.scalar_one_or_none()
            
            if not session:
                raise ValueError(f"Sesja {session_id} nie zosta≈Ça znaleziona")
                
            # 2. Znajd≈∫ pytanie w active_clarifying_questions
            active_questions = list(session.active_clarifying_questions) if session.active_clarifying_questions else []
            answered_question = None
            remaining_questions = []
            
            for q in active_questions:
                if q.get('id') == question_id:
                    answered_question = q
                else:
                    remaining_questions.append(q)
            
            if not answered_question:
                raise ValueError(f"Pytanie {question_id} nie zosta≈Ço znalezione w aktywnych pytaniach")
            
            # 3. Stw√≥rz "sztucznƒÖ" interakcjƒô z odpowiedziƒÖ sprzedawcy
            observation_text = f"Sprzedawca zaobserwowa≈Ç: {answered_question.get('question', '')} - Odpowied≈∫: {answer}"
            
            # Dodaj observation do psychological context (nie tworzymy fizycznej interakcji)
            current_profile = dict(session.cumulative_psychology) if session.cumulative_psychology else {}
            if 'observations' not in current_profile:
                current_profile['observations'] = []
            
            current_profile['observations'].append({
                'question': answered_question.get('question', ''),
                'answer': answer,
                'timestamp': datetime.now().isoformat(),
                'psychological_target': answered_question.get('psychological_target', 'general')
            })
            
            # 4. Usu≈Ñ odpowiedziane pytanie
            await db.execute(
                update(Session)
                .where(Session.id == session_id)
                .values(
                    active_clarifying_questions=remaining_questions,
                    cumulative_psychology=current_profile
                )
            )
            await db.commit()
            
            # 5. Uruchom full cycle update
            updated_profile = await self.update_cumulative_profile(session_id, db)
            
            logger.info(f"‚úÖ [CLARIFYING] Pytanie {question_id} processed, pozosta≈Ço {len(remaining_questions)} pyta≈Ñ")
            return updated_profile
            
        except Exception as e:
            logger.error(f"‚ùå [CLARIFYING] B≈ÇƒÖd podczas answer_clarifying_question: {e}")
            raise

    def _build_session_conversation_history(self, interactions: List[Interaction]) -> str:
        """Buduje pe≈ÇnƒÖ historiƒô konwersacji sesji dla AI"""
        if not interactions:
            return "BRAK HISTORII ROZMOWY"
            
        history_parts = ["=== HISTORIA CA≈ÅEJ SESJI ==="]
        
        # Sortuj interactions po timestamp (convert Column to datetime)
        sorted_interactions = sorted(interactions, key=lambda x: x.timestamp.timestamp() if hasattr(x.timestamp, 'timestamp') else x.timestamp)
        
        for i, interaction in enumerate(sorted_interactions):
            timestamp = interaction.timestamp.strftime("%H:%M:%S")
            history_parts.append(f"[{i+1}] {timestamp} - Sprzedawca: {interaction.user_input}")
            
            # Dodaj insights z AI response je≈õli sƒÖ
            if interaction.ai_response_json:
                insights = interaction.ai_response_json.get('main_analysis', '')
                if insights:
                    history_parts.append(f"    AI Insight: {insights[:200]}...")
        
        history_parts.append("=== KONIEC HISTORII ===")
        return "\n".join(history_parts)

    def _build_cumulative_psychology_prompt(self, history: str, current_profile: Dict, confidence: int) -> str:
        """
        Tworzy enhanced prompt dla AI z full context
        """
        archetyp_definitions = "\n".join([
            f"- {archetype['name']}: {archetype['description']}" 
            for archetype in self.CUSTOMER_ARCHETYPES.values()
        ])
        
        return f"""
Jeste≈õ ekspertem psychologii sprzeda≈ºy prowadzƒÖcym CIƒÑG≈ÅƒÑ, EWOLUUJƒÑCƒÑ analizƒô klienta na poziomie CA≈ÅEJ SESJI.

TWOJE ZADANIE - 4 KROKI:

KROK 1 - AKTUALIZACJA PROFILU:
Na podstawie pe≈Çnej historii sesji i obecnego profilu, zaktualizuj i rozwi≈Ñ profil psychometryczny klienta.
Uwzglƒôdnij WSZYSTKIE interakcje i obserwacje sprzedawcy.

KROK 2 - OCENA PEWNO≈öCI:
Oblicz nowy poziom pewno≈õci analizy (0-100%) na podstawie ilo≈õci i jako≈õci dostƒôpnych danych.

KROK 3 - SUGGESTED QUESTIONS:
Je≈õli pewno≈õƒá < 80%, wygeneruj 2-4 konkretne pytania kt√≥re sprzedawca mo≈ºe zadaƒá klientowi lub zaobserwowaƒá.

KROK 4 - SYNTEZA ARCHETYPU (KLUCZOWE!):
Je≈õli pewno≈õƒá >= 70%, wykonaj natychmiastowƒÖ syntezƒô:
1. Przeanalizuj ca≈Çy profil psychologiczny (Big Five + DISC + Warto≈õci Schwartza)
2. Przypisz klienta do najlepiej pasujƒÖcego archetypu:
{archetyp_definitions}
3. Wygeneruj 3 konkretne porady "R√≥b to / Nie r√≥b tego" specyficzne dla tego archetypu i tego konkretnego klienta

DANE WEJ≈öCIOWE:

HISTORIA SESJI:
{history}

OBECNY PROFIL PSYCHOMETRYCZNY (confidence: {confidence}%):
{json.dumps(current_profile, ensure_ascii=False, indent=2) if current_profile else "BRAK PROFILU"}

ZWR√ìƒÜ WYNIK WY≈ÅƒÑCZNIE JAKO JSON Z PE≈ÅNYMI OBIEKTAMI:
{{
  "cumulative_psychology": {{
    "big_five": {{ 
      "openness": {{ "score": 7, "rationale": "Uzasadnienie AI", "strategy": "Strategia sprzeda≈ºowa" }},
      "conscientiousness": {{ "score": 8, "rationale": "Uzasadnienie AI", "strategy": "Strategia sprzeda≈ºowa" }},
      "extraversion": {{ "score": 5, "rationale": "Uzasadnienie AI", "strategy": "Strategia sprzeda≈ºowa" }},
      "agreeableness": {{ "score": 4, "rationale": "Uzasadnienie AI", "strategy": "Strategia sprzeda≈ºowa" }},
      "neuroticism": {{ "score": 3, "rationale": "Uzasadnienie AI", "strategy": "Strategia sprzeda≈ºowa" }}
    }},
    "disc": {{ 
      "dominance": {{ "score": 6, "rationale": "Uzasadnienie AI", "strategy": "Strategia sprzeda≈ºowa" }},
      "influence": {{ "score": 4, "rationale": "Uzasadnienie AI", "strategy": "Strategia sprzeda≈ºowa" }},
      "steadiness": {{ "score": 3, "rationale": "Uzasadnienie AI", "strategy": "Strategia sprzeda≈ºowa" }},
      "compliance": {{ "score": 8, "rationale": "Uzasadnienie AI", "strategy": "Strategia sprzeda≈ºowa" }}
    }},
    "schwartz_values": [{{ "value_name": "Bezpiecze≈Ñstwo", "strength": 8, "rationale": "Uzasadnienie AI", "strategy": "Strategia sprzeda≈ºowa", "is_present": true }}, ...],
    "observations_summary": "Kluczowe obserwacje z ca≈Çej sesji"
  }},
  "psychology_confidence": 85,
  "suggested_questions": [
    {{ "question": "Konkretne pytanie do klienta", "psychological_target": "Co ma sprawdziƒá" }}
  ],
  "customer_archetype": {{
    "archetype_key": "analityk",
    "archetype_name": "üî¨ Analityk",
    "confidence": 90,
    "key_traits": ["analityczny", "ostro≈ºny", "szczeg√≥≈Çowy", "sceptyczny"],
    "description": "Klient o wysokiej sumienno≈õci i potrzebie bezpiecze≈Ñstwa. Podejmuje decyzje na podstawie danych.",
    "sales_strategy": {{
      "do": ["Prezentuj szczeg√≥≈Çowe dane TCO", "Pokazuj certyfikaty i nagrody", "Daj czas na przemy≈õlenie", "U≈ºywaj wykres√≥w i tabel"],
      "dont": ["Nie wywieraj presji czasowej", "Nie pomijaj technicznych szczeg√≥≈Ç√≥w", "Nie u≈ºywaj emocjonalnych argument√≥w", "Nie przerywaj jego analiz"]
    }},
    "motivation": "Bezpiecze≈Ñstwo inwestycji i minimalizacja ryzyka",
    "communication_style": "Faktyczny, szczeg√≥≈Çowy, oparty na danych"
  }}
}}
"""

    def _parse_psychology_ai_response(self, ai_response: str) -> Optional[Dict[str, Any]]:
        """Parsuje odpowied≈∫ AI z analizƒÖ psychometrycznƒÖ"""
        try:
            # Znajd≈∫ JSON w odpowiedzi
            start_idx = ai_response.find('{')
            end_idx = ai_response.rfind('}') + 1
            
            if start_idx == -1 or end_idx == 0:
                logger.warning("‚ö†Ô∏è [PSYCHOLOGY PARSE] Brak JSON w odpowiedzi AI")
                return None
                
            json_str = ai_response[start_idx:end_idx]
            parsed_data = json.loads(json_str)
            
            logger.info(f"‚úÖ [PSYCHOLOGY PARSE] Sparsowano: confidence={parsed_data.get('psychology_confidence', 0)}%")
            
            # DEBUG: Log szczeg√≥≈Çowych danych psychology
            cumulative = parsed_data.get('cumulative_psychology', {})
            big_five = cumulative.get('big_five', {})
            disc = cumulative.get('disc', {})
            archetype = parsed_data.get('customer_archetype', {})
            
            logger.info(f"üß† [DEBUG BIG FIVE] {big_five}")
            logger.info(f"üéØ [DEBUG DISC] {disc}")  
            logger.info(f"üë§ [DEBUG ARCHETYPE] {archetype}")
            
            return parsed_data
            
        except json.JSONDecodeError as e:
            logger.warning(f"‚ö†Ô∏è [PSYCHOLOGY PARSE] JSON decode error: {e}")
            return None
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è [PSYCHOLOGY PARSE] Unexpected error: {e}")
            return None

    def _convert_to_interactive_questions(self, suggested_questions: List[Dict]) -> List[Dict]:
        """
        ETAP 3: Konwertuje suggested_questions na format interaktywnych pyta≈Ñ dla UI
        
        Z: {"question": "Czy klient pyta o TCO?", "psychological_target": "conscientiousness"}
        Do: {"id": "q1", "question": "Czy klient pyta o TCO?", "option_a": "Tak, pyta", "option_b": "Nie, nie pyta"}
        """
        interactive_questions = []
        
        for i, sq in enumerate(suggested_questions):
            question_text = sq.get('question', '')
            psychological_target = sq.get('psychological_target', 'general assessment')
            
            # Generate sensible A/B options based on question type
            if any(word in question_text.lower() for word in ['czy', 'jak czƒôsto', 'jakie']):
                option_a = "Tak, potwierdza"
                option_b = "Nie, zaprzecza"
            elif 'jak' in question_text.lower():
                option_a = "Szybko, bezpo≈õrednio" 
                option_b = "Powoli, szczeg√≥≈Çowo"
            elif 'co' in question_text.lower():
                option_a = "Korzy≈õci og√≥lne"
                option_b = "Szczeg√≥≈Çy techniczne"
            else:
                option_a = "Potwierdza"
                option_b = "Zaprzecza"
            
            interactive_questions.append({
                "id": f"sq_{i+1}",
                "question": question_text,
                "option_a": option_a,
                "option_b": option_b,
                "psychological_target": psychological_target
            })
        
        return interactive_questions

    async def _update_session_psychology(
        self, 
        db: AsyncSession, 
        session_id: int, 
        ai_result: Dict[str, Any], 
        interactive_questions: List[Dict]
    ):
        """Zapisuje wyniki analizy w sesji"""
        try:
            update_data = {
                'cumulative_psychology': ai_result.get('cumulative_psychology'),
                'psychology_confidence': ai_result.get('psychology_confidence', 0),
                'active_clarifying_questions': interactive_questions,
                'customer_archetype': ai_result.get('customer_archetype'),
                'psychology_updated_at': datetime.now()
            }
            
            await db.execute(
                update(Session)
                .where(Session.id == session_id)
                .values(**update_data)
            )
            await db.commit()
            
            logger.info(f"‚úÖ [SESSION UPDATE] Psychology data saved for session {session_id}")
            
        except Exception as e:
            logger.error(f"‚ùå [SESSION UPDATE] Error updating session {session_id}: {e}")
            raise

# Singleton instance
session_psychology_engine = SessionPsychologyEngine()
